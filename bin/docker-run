#!/bin/bash

hr="=========="

readonly SEQUELIZE_CLI="node_modules/.bin/sequelize"
readonly DEFAULT_ENV='local'
readonly -a ENVIRONMENTS=("$DEFAULT_ENV" "test")

# Array of subcommands
readonly -a subcommands=(
    usage
    setup
    teardown
    start
    stop
    db
    lint
    tests
)

declare -a conf


setup() {
    # First, setup up frontend and backend, install dependencies
    # yarn docker:deps
    setup_backend
    setup_frontend

    db_setup ""

    # Stop the db manually?
    # db_stop
}

setup_backend() {
    echo "${hr} Setting up backend ${hr}"
    docker-compose "${conf[@]}" run --rm backend yarn install
}

setup_frontend() {
    echo "${hr} Setting up frontend ${hr}"
    docker-compose "${conf[@]}" run --rm frontend yarn install
}

teardown() {
    docker-compose \
        "${conf[@]}" \
        down --volumes
}

db_migrate() {
    local -a options=(status undo)
    local option="${1}"
    # If 'undo' param provided undo
    if [[ "undo" == "${option}" ]]; then
        echo "${hr} Undoing db migrations ${hr}"
        docker-compose "${conf[@]}" run --rm backend "$SEQUELIZE_CLI" db:migrate:undo
        exit 0
    fi

    if [[ "status" == "${option}" ]]; then
        echo "${hr} Checking db migration status ${hr}"
        docker-compose "${conf[@]}" run --rm backend "$SEQUELIZE_CLI" db:migrate:status
        exit 0
    fi

    # Create/update database tables
    # yarn docker:db:migrate
    echo "${hr} Migrating db ${hr}"
    docker-compose "${conf[@]}" run --rm backend "$SEQUELIZE_CLI" db:migrate
}

db_seed() {
    local option="${1}"
    # If 'undo' param provided undo
    if [[ "undo" == "${option}" ]]; then
        echo "${hr} Unseeding db ${hr}"
        docker-compose "${conf[@]}" run --rm backend "$SEQUELIZE_CLI" db:seed:undo:all
        exit 0
    fi

    # Populate db with data
    # yarn docker:db:seed
    echo "${hr} Seeding database ${hr}"
    docker-compose "${conf[@]}" run --rm backend yarn db:seed
}

db_setup() {
    db_migrate ""
    db_seed ""
}

db_stop() {
    docker-compose "${conf[@]}" stop db
}

# Need reliable way to remove db volume and only db volume
# db_destroy() {
#     db_stop
#     docker-compose rm -v -- db
#     docker volume prune
# }

db() {
    declare -a options=(setup migrate seed stop)
    option="${1}"
    for i in "${options[@]}"; do
        if [ "${i}" == "${option}" ]; then
            shift 2>/dev/null
            "db_${option}" "$@"
            exit 0
        fi
    done

    # If no matching option, print options
    echo "db expects one of the following: ${options[*]}"
    exit 1
}

test_frontend() {
    echo "${hr} Running frontend tests ${hr}"
    docker-compose "${conf[@]}" run --rm frontend yarn test:ci
}

test_backend() {
    echo "${hr} Running backend tests ${hr}"
    docker-compose "${conf[@]}" run --rm backend yarn test:ci
}

# tests plural, because `test` is a builtin shell command
tests() {
    declare -a options=(frontend backend)
    option="${1}"

    # Check if user specified 'frontend' or 'backend' option
    if [[ -n $option ]]; then
        for i in "${options[@]}"; do
            if [ "${i}" == "${option}" ]; then
                "test_${option}"
                exit 0
            fi
        done
    fi

    # Otherwise, run both
    test_frontend
    test_backend

}

lint_backend() {
    echo "${hr} Linting backend ${hr}"
    docker-compose "${conf[@]}" run --rm backend yarn lint:ci
}

lint_frontend() {
    echo "${hr} Linting frontend ${hr}"
    docker-compose "${conf[@]}" run --rm frontend yarn lint:ci
}

lint() {
    local -a options=(frontend backend)
    option="${1}"

    for i in "${options[@]}"; do
        if [[ "${i}" == "$option" ]]; then
            "lint_${option}"
            exit 0
        fi
    done

    lint_frontend
    lint_backend
}

start() {
    docker-compose "${conf[@]}" up
}

stop() {
    docker-compose "${conf[@]}" down
}

# ===== Process env configs

# We want to specify multiple config files, per
# https://docs.docker.com/compose/extends/#multiple-compose-files
compose_conf() {
    local env="${1}"
    local envfile="docker-compose.${env}.yml"

    if [[ ! -e "$envfile" ]]; then
        echo "$envfile does not appear to exist!"
        exit 1
    fi

    configs=(
        '-f docker-compose.yml'
        "-f docker-compose.${env}.yml"
    )

    echo "${configs[@]}"
}

# ===== Usage =====

usage() {
    # shellcheck disable=SC2086
    cat <<EOF >&2
Run commands in Docker containers
Usage: $0 [-h] [-e env] <subcommand...>
Subcommands:
    ${subcommands[*]}
EOF
}

# ====== Main =====

check_env() {
    local env_match=0
    for e in "${ENVIRONMENTS[@]}"; do
        if [[ "$e" == "${1}" ]]; then
            env_match=1;
            break;
        fi
    done
    if [[ $env_match -eq 0 ]]; then
        echo "Invalid environment '${1}'";
        echo "Valid environments are: ${ENVIRONMENTS[*]}"
        exit 1;
    fi
}

main() {
    docker_env="${DOCKER_ENV:-$DEFAULT_ENV}"
    local env_conf="$docker_env"
    check_env "$env_conf"

    # Parse -options
    while getopts ":e:h" opt; do
        case $opt in
            e)
                env_conf="${OPTARG:-$env_conf}"
                check_env "$env_conf"
                ;;
            h)
                usage
                exit
                ;;
            \?)
                echo "Invalid option" >&2
                echo
                ;;
        esac
    done

    # After parsing options, shift so $@ has only params
    shift $((OPTIND -1))

    # Pull first param as subcommand, default to 'usage' if no args provided
    local subcmd="${1:-usage}";

    # Shift parameters, so $@a has remaining params
    shift 2>/dev/null

    # If subcommand is empty string, print usage
    if [ -z "$subcmd" ]; then
        usage
        exit 1
    fi

    # 'conf' is an array, so we follow https://github.com/koalaman/shellcheck/wiki/SC2207
    IFS=" " read -r -a conf <<< "$(compose_conf "$env_conf")"

    # Loop over subcommands, look for match with $subcommand. Execute fn if match
    for i in "${subcommands[@]}"; do
        if [[ "${i}" == "${subcmd}" ]]; then
            "${subcmd}" "$@"
            exit 0
        fi
    done

    # If we didn't run a subcommand and exit already, print usage
    usage
}

main "$@"
