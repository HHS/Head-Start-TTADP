#!/bin/bash

hr="=========="

readonly SEQUELIZE_CLI="node_modules/.bin/sequelize"
readonly DEFAULT_ENV='local'
readonly TEST_ENV='test'
readonly -a ENVIRONMENTS=("$DEFAULT_ENV" "$TEST_ENV")
readonly DB_SERVICE='db'

# Array of subcommands
readonly -a subcommands=(
    usage
    setup
    teardown
    start
    stop
    db
    lint
    'test'
)

# conf should be assigned a string like `-f docker-compose.yml -f docker-compose.locale.yml`/conf
declare conf
declare -i env_override=0

# Expects a command as a string, which it will echo and then execute
echo_exec() {
    local cmd="${1}"
    echo "$cmd"
    $cmd
}

setup() {
    # First, setup up frontend and backend, install dependencies
    # yarn docker:deps
    setup_backend
    setup_frontend

    db_setup ""

    # Stop the db manually?
    # db_stop
}

setup_backend() {
    echo "${hr} Setting up backend ${hr}"
    echo_exec "docker-compose ${conf} run --rm backend yarn install"
}

setup_frontend() {
    echo "${hr} Setting up frontend ${hr}"
    echo_exec "docker-compose ${conf} run --rm frontend yarn install"
    echo "$cmd"
    $cmd
}

teardown() {
    docker-compose \
        "${conf}" \
        down --volumes
}

db_migrate() {
    local -a options=(status undo)
    local option="${1}"
    # If 'undo' param provided undo
    if [[ "undo" == "${option}" ]]; then
        echo "${hr} Undoing db migrations ${hr}"
        echo_exec "docker-compose ${conf} run --rm backend $SEQUELIZE_CLI db:migrate:undo"
        echo "$cmd"
        $cmd
        exit 0
    fi

    if [[ "status" == "${option}" ]]; then
        echo "${hr} Checking db migration status ${hr}"
        echo_exec "docker-compose ${conf} run --rm backend $SEQUELIZE_CLI db:migrate:status"
        echo "$cmd"
        $cmd
        exit 0
    fi

    # Create/update database tables
    # yarn docker:db:migrate
    echo "${hr} Migrating db ${hr}"
    echo_exec "docker-compose ${conf} run --rm backend $SEQUELIZE_CLI db:migrate"
    echo "$cmd"
    $cmd
}

db_seed() {
    local option="${1}"
    # If 'undo' param provided undo
    if [[ "undo" == "${option}" ]]; then
        echo "${hr} Unseeding db ${hr}"
        echo_exec "docker-compose ${conf} run --rm backend $SEQUELIZE_CLI db:seed:undo:all"
        echo "$cmd"
        $cmd
        exit 0
    fi

    # Populate db with data
    # yarn docker:db:seed
    echo "${hr} Seeding database ${hr}"
    echo_exec "docker-compose ${conf} run --rm backend yarn db:seed"
    echo "$cmd"
    $cmd
}

db_setup() {
    db_migrate ""
    db_seed ""
}

db_stop() {
    echo_exec "docker-compose ${conf} stop db"
    echo "$cmd"
    $cmd
}

# Need reliable way to remove db volume and only db volume
# db_destroy() {
#     db_stop
#     docker-compose rm -v -- db
#     docker volume prune
# }

db_exists() {
    # TODO: Less naive detection of database service/image/volume
    db_lookup="$(docker-compose images --quiet $DB_SERVICE)"
    if [[ -n "$db_lookup" ]]; then
        return 1
    fi
    return 0
}

db() {
    declare -a options=(setup migrate seed stop)
    option="${1}"
    for i in "${options[@]}"; do
        if [ "${i}" == "${option}" ]; then
            shift 2>/dev/null
            "db_${option}" "$@"
            exit 0
        fi
    done

    # If no matching option, print options
    echo "db expects one of the following: ${options[*]}"
    exit 1
}

test_frontend() {
    echo "${hr} Running frontend tests ${hr}"
    echo_exec "docker-compose ${conf} run --rm frontend yarn test:ci"
    echo "$cmd"
    $cmd
}

test_backend() {
    # Check if db_exists, if not setup db
    local -i has_db
    has_db=$(db_exists)
    if [[ has_db -eq 0 ]]; then
        echo "${hr} Setting up database prior to testing ${hr}"
        db_setup
    fi
    echo "${hr} Running backend tests ${hr}"
    echo_exec "docker-compose ${conf} run --rm backend yarn test:ci"
    echo "$cmd"
    $cmd
    db_stop
}

# 'run_tests', because `test` is a builtin shell command
run_tests() {
    declare -a options=(frontend backend)
    option="${1}"

    # Check if user specified 'frontend' or 'backend' option
    if [[ -n $option ]]; then
        for i in "${options[@]}"; do
            if [ "${i}" == "${option}" ]; then
                "test_${option}"
                exit 0
            fi
        done
    fi

    # Otherwise, run both
    test_frontend
    test_backend

}

lint_backend() {
    echo "${hr} Linting backend ${hr}"
    echo_exec "docker-compose ${conf} run --rm backend yarn lint:ci"
    echo "$cmd"
    $cmd
}

lint_frontend() {
    echo "${hr} Linting frontend ${hr}"
    echo_exec "docker-compose ${conf} run --rm frontend yarn lint:ci"
    echo "$cmd"
    $cmd
}

lint() {
    local -a options=(frontend backend)
    option="${1}"

    for i in "${options[@]}"; do
        if [[ "${i}" == "$option" ]]; then
            "lint_${option}"
            exit 0
        fi
    done

    lint_frontend
    lint_backend
}

start() {
    echo_exec "docker-compose ${conf} up"
    echo "$cmd"
    $cmd
}

stop() {
    echo_exec "docker-compose ${conf} down"
    echo "$cmd"
    $cmd
}

# ===== Process env configs

# We want to specify multiple config files, per
# https://docs.docker.com/compose/extends/#multiple-compose-files
compose_conf() {
    local env="${1}"
    local envfile="docker-compose.${env}.yml"

    if [[ ! -e "$envfile" ]]; then
        echo "$envfile does not appear to exist!"
        exit 1
    fi

    configs=(
        '-f docker-compose.yml'
        "-f docker-compose.${env}.yml"
    )

    echo "${configs[@]}"
    return 0
}

# ===== Usage =====

usage() {
    # shellcheck disable=SC2086
    cat <<EOF >&2
Run commands in Docker containers
Usage: $0 [-h] [-e env] <subcommand...>
Subcommands:
    ${subcommands[*]}
EOF
}

# ====== Main =====

check_env() {
    local env_match=0
    for e in "${ENVIRONMENTS[@]}"; do
        if [[ "$e" == "${1}" ]]; then
            env_match=1;
            break;
        fi
    done
    if [[ $env_match -eq 0 ]]; then
        echo "Invalid environment '${1}'";
        echo "Valid environments are: ${ENVIRONMENTS[*]}"
        exit 1;
    fi
}

main() {
    docker_env="${DOCKER_ENV:-$DEFAULT_ENV}"
    if [[ -n "$DOCKER_ENV" ]]; then
        env_override=1
    fi
    local env_conf="$docker_env"
    check_env "$env_conf"

    # Parse -options
    while getopts ":e:h" opt; do
        case $opt in
            e)
                env_conf="${OPTARG:-$env_conf}"
                check_env "$env_conf"
                env_override=1
                ;;
            h)
                usage
                exit
                ;;
            \?)
                echo "Invalid option" >&2
                echo
                ;;
        esac
    done

    # After parsing options, shift so $@ has only params
    shift $((OPTIND -1))

    # Pull first param as subcommand, default to 'usage' if no args provided
    local subcmd="${1:-usage}";

    # Shift parameters, so $@a has remaining params
    shift 2>/dev/null

    # If subcommand is empty string, print usage
    if [ -z "$subcmd" ]; then
        usage
        exit 1
    fi

    conf=$(compose_conf "$env_conf")

    # Loop over subcommands, look for match with $subcommand. Execute fn if match
    for i in "${subcommands[@]}"; do
        if [[ "${i}" == "${subcmd}" ]]; then
            if [[ "${subcmd}" == "test" ]]; then
                if [[ $env_override -eq 0 ]]; then
                    echo "${hr}> Test commands use 'test' config, unless overridden <${hr}"
                    conf=$(compose_conf "$TEST_ENV")
                else
                    echo "Running tests in '$env_conf'"
                fi
                subcmd="run_tests";
            fi
            "${subcmd}" "$@"
            exit 0
        fi
    done

    # If we didn't run a subcommand and exit already, print usage
    usage
}

main "$@"
