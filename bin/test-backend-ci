#!/usr/bin/env node
/**
 * Runs backend Jest batches (root + domain folders + tools), writes JUnit to reports/,
 * and prints a concise failure summary. Coverage merging is handled in CI separately.
 */
const { spawnSync } = require('child_process');
const path = require('path');
const fs = require('fs');
const { parseStringPromise } = require('xml2js');

const ROOT = process.cwd();
const JEST = path.join(ROOT, 'node_modules', '.bin', 'jest');
const REPORT_DIR = path.join(ROOT, 'reports');
const DEFAULT_ENV = {
  POSTGRES_USERNAME: 'postgres',
  POSTGRES_DB: 'ttasmarthub',
  CURRENT_USER_ID: '5',
  CI: 'true',
};

const batches = [
  { name: 'root', testPath: 'src/*.js', coverageFrom: 'src/*.{js,ts}', coverageDir: 'coverage/src/root', coverage: true },
  ...['lib', 'middleware', 'models', 'policies', 'routes', 'scopes', 'services', 'widgets', 'goalServices'].map((t) => ({
    name: t,
    testPath: `src/${t}`,
    coverageFrom: `src/${t}/**/!(*CLI).{js,ts}`,
    coverageDir: `coverage/src/${t}`,
    coverage: true,
  })),
  { name: 'tools', testPath: 'tools', coverage: false },
];

let exitCode = 0;
const failFast = process.env.FAIL_FAST === 'true' || process.env.FAIL_FAST === '1';

function runJestBatch(batch) {
  const env = {
    ...process.env,
    ...DEFAULT_ENV,
    JEST_JUNIT_OUTPUT_DIR: 'reports',
    JEST_JUNIT_OUTPUT_NAME: `${batch.name}.xml`,
  };

  const args = [
    '--expose-gc',
    JEST,
    batch.testPath,
    batch.coverage === false ? '--coverage=false' : '--coverage',
    '--colors',
    '--reporters=jest-junit',
    '--reporters=default',
    '--runInBand',
    '--silent',
    '--logHeapUsage',
    '--forceExit',
  ];

  if (batch.coverageDir) {
    args.push(`--coverageDirectory=${path.join(ROOT, batch.coverageDir)}`);
  }
  if (batch.coverageFrom) {
    args.push(`--collectCoverageFrom=${batch.coverageFrom}`);
  }

  const res = spawnSync('node', args, { stdio: 'inherit', env });
  if (res.status !== 0) {
    exitCode += 1;
    return false;
  }
  return true;
}

async function summarizeReports() {
  console.log('----- Test Failure Summary -----');

  const limit = 5;
  for (const { name } of batches) {
    const reportPath = path.join(REPORT_DIR, `${name}.xml`);
    if (!fs.existsSync(reportPath)) continue;

    try {
      const xml = fs.readFileSync(reportPath, 'utf8');
      const data = await parseStringPromise(xml, { explicitArray: true, mergeAttrs: true });

      const suites = [];
      if (data && data.testsuites && data.testsuites[0]) {
        suites.push(...(data.testsuites[0].testsuite || []));
      } else if (data && data.testsuite && data.testsuite[0]) {
        suites.push(data.testsuite[0]);
      }
      if (suites.length === 0) {
        console.log(`${name}: unable to summarize (no testsuite data)`);
        continue;
      }

      const counts = suites.reduce((acc, s) => {
        acc.tests += Number(s.tests || 0);
        acc.failures += Number(s.failures || 0);
        acc.errors += Number(s.errors || 0);
        acc.time += Number(s.time || 0);
        return acc;
      }, { tests: 0, failures: 0, errors: 0, time: 0 });

      const failures = [];
      suites.forEach((suite) => {
        (suite.testcase || []).forEach((tc) => {
          const failure = (tc.failure && tc.failure[0]) || (tc.error && tc.error[0]);
          if (failure) {
            const message = (failure.message || failure._ || '').toString().trim();
            failures.push({
              classname: tc.classname || '',
              name: tc.name || '',
              message,
            });
          }
        });
      });

      const status = counts.failures + counts.errors === 0 ? 'PASS' : 'FAIL';
      console.log(`${name}: ${status} (${counts.tests} tests, ${counts.failures} failures, ${counts.errors} errors, ${counts.time.toFixed(2)}s)`);
      failures.slice(0, limit).forEach((f) => {
        const msg = f.message ? ` :: ${f.message.slice(0, 120)}` : '';
        console.log(`  - ${f.classname} :: ${f.name}${msg}`);
      });
    } catch (err) {
      console.log(`${name}: unable to summarize (${err.message})`);
    }
  }
}

async function main() {
  for (const batch of batches) {
    const ok = runJestBatch(batch);
    if (!ok && failFast) {
      console.log('>>>>>>>> fail-fast: stopping after first failing batch');
      break;
    }
  }
  await summarizeReports();
  process.exit(exitCode);
}

main();
